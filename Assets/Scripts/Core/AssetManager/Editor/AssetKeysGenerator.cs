using System.Collections.Generic;
using System.IO;
using System.Text;
using UnityEditor;
using UnityEngine;
using YuankunHuang.Unity.Core;

namespace YuankunHuang.Unity.AssetCore.Editor
{
    public static class AssetKeysGenerator
    {
        public static readonly string CONFIG_PATH = "Assets/Settings/AssetManagerConfig.asset";
        public static readonly string OUTPUT_PATH = "Assets/Scripts/Generated/AssetKeys.cs";

        [MenuItem("Tools/AssetManager/Generate Asset Keys")]
        public static void GenerateAssetKeys()
        {
            var config = FindAssetManagerConfig();
            if (config == null)
            {
                LogHelper.LogError($"AssetManagerConfig not found. Please create one in the project.");
                return;
            }

            config.ClearInvalidEntries();

            // genearte code
            var code = GenerateCode(config);

            // write to file
            WriteToFile(code);

            // refresh asset database
            AssetDatabase.Refresh();

            LogHelper.Log("Asset keys generated successfully.");
        }

        private static void WriteToFile(string code)
        {
            var directory = Path.GetDirectoryName(OUTPUT_PATH);
            if (!Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory);
            }

            File.WriteAllText(OUTPUT_PATH, code);
        }

        private static string GenerateCode(AssetManagerConfig config)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("//     This code was auto-generated by AssetKeysGenerator.");
            sb.AppendLine("//     DO NOT MODIFY THIS FILE MANUALLY!");
            sb.AppendLine("//     Changes will be lost when the code is regenerated.");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine($"// Generated at: {System.DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            sb.AppendLine();

            sb.AppendLine("namespace YuankunHuang.Unity.AssetCore");
            sb.AppendLine("{");
            sb.AppendLine("    public static class AssetKeys");
            sb.AppendLine("    {");

            GenerateKeys(sb, config);

            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }

        private static void GenerateKeys(StringBuilder sb, AssetManagerConfig config)
        {
            var groups = new Dictionary<AssetType, List<AssetEntry>>();
            foreach (var entry in config.AssetEntries)
            {
                var type = entry.type;
                if (!groups.TryGetValue(type, out var list))
                {
                    list = new List<AssetEntry>();
                    groups[type] = list;
                }
                list.Add((AssetEntry)entry);
            }

            foreach (var kv in groups)
            {
                GenerateGroupedKeys(sb, kv.Key, kv.Value);
            }
        }

        private static void GenerateGroupedKeys(StringBuilder sb, AssetType type, List<AssetEntry> entries)
        {
            if (entries.Count == 0) return;
            sb.AppendLine($"        public static class {GetClassNameForType(type)}");
            sb.AppendLine("        {");
            foreach (var entry in entries)
            {
                var constName = ConvertToValidIdentifier(entry.key);
                sb.AppendLine($"            public const string {constName} = \"{entry.key}\";");
            }
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private static string ConvertToValidIdentifier(string name)
        {
            if (string.IsNullOrEmpty(name))
            {
                return "InvalidIdentifier";
            }

            var sb = new StringBuilder();
            var nextUpper = true;
            foreach (var c in name)
            {
                if (char.IsLetterOrDigit(c))
                {
                    if (nextUpper)
                    {
                        sb.Append(char.ToUpper(c));
                        nextUpper = false;
                    }
                    else
                    {
                        sb.Append(c);
                    }
                }
                else
                {
                    sb.Append('_'); // replace invalid characters with underscore
                    nextUpper = true; // next character should be uppercase
                }
            }

            if (sb.Length > 0 && char.IsDigit(sb[0]))
            {
                sb.Insert(0, '_'); // ensure identifier does not start with a digit
            }

            if (string.IsNullOrEmpty(sb.ToString()) || IsCSharpKeyword(sb.ToString()))
            {
                sb.Insert(0, "Asset_"); // prefix if it's empty or a keyword
            }

            return sb.ToString();
        }

        private static bool IsCSharpKeyword(string word)
        {
            // manually maintain this set of C# keywords
            // lightweight but useful
            var keywords = new HashSet<string>
            {
                "abstract", "as", "base", "bool", "break", "byte",
                "case", "catch", "char", "checked", "class", "const",
                "continue", "decimal", "default", "delegate", "do", "double",
                "else", "enum", "event", "explicit", "extern", "false",
                "finally", "fixed", "float", "for", "foreach", "goto",
                "if", "implicit", "in", "int", "interface", "internal",
                "is", "lock", "long", "namespace", "new", "null",
                "object", "operator", "out", "override", "params", "private",
                "protected", "public", "readonly", "ref", "return", "sbyte",
                "sealed", "short", "sizeof", "stackalloc", "static", "string",
                "struct", "switch", "this", "throw", "true", "try",
                "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort",
                "using", "virtual", "void", "volatile", "while"
            };

            return keywords.Contains(word.ToLower());
        }

        private static string GetClassNameForType(AssetType type)
        {
            return type switch
            {
                AssetType.Texture2D => "Texture2Ds",
                AssetType.Sprite => "Sprites",
                AssetType.GameObject => "GameObjects",
                AssetType.Font => "Fonts",
                AssetType.TMP_ColorGradient => "TMP_ColorGradients",
                AssetType.AnimationClip => "AnimationClips",
                AssetType.AudioClip => "AudioClips",
                AssetType.Material => "Materials",
                AssetType.Shader => "Shaders",
                AssetType.TextAsset => "TextAssets",
                AssetType.ScriptableObject => "ScriptableObjects",
                AssetType.Animation => "Animations",
                AssetType.SpriteAtlas => "SpriteAtlases",
                AssetType.AnimatorController => "AnimatorControllers",
                _ => $"{type.ToString()}_s"
            };
        }

        private static AssetManagerConfig FindAssetManagerConfig()
        {
            var config = AssetDatabase.LoadAssetAtPath<AssetManagerConfig>(CONFIG_PATH);
            if (config == null)
            {
                var guids = AssetDatabase.FindAssets("t:AssetManagerConfig");
                if (guids.Length > 0)
                {
                    var path = AssetDatabase.GUIDToAssetPath(guids[0]);
                    config = AssetDatabase.LoadAssetAtPath<AssetManagerConfig>(path);
                    LogHelper.LogWarning($"AssetManagerConfig found at {path}, consider moving it to {CONFIG_PATH}");
                }
            }

            return config;
        }
    }
}